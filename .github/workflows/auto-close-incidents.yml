name: Auto-close incidents when site is back up

on:
  schedule:
    - cron: "*/30 * * * *" # every 30 minutes
  workflow_dispatch:
    inputs:
      okStatusCodes:
        description: "Comma-separated status codes that also count as UP (in addition to 200-399)"
        required: false
        default: "401,403" # many sites block bots

# Needed so the job can read issues and close them
permissions:
  contents: read
  issues: write

concurrency:
  group: autoclose-${{ github.ref }}
  cancel-in-progress: false

jobs:
  autoclose:
    runs-on: ubuntu-latest
    steps:
      - name: Check open incidents and close those back up
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Input parsing
            const explicitOk = (core.getInput('okStatusCodes') || '401,403')
              .split(',')
              .map(s => parseInt(s.trim(), 10))
              .filter(n => Number.isFinite(n));

            // Fetch all open issues, 100 per page
            async function getOpenIssues() {
              const all = [];
              let page = 1;
              while (true) {
                const { data } = await github.rest.issues.listForRepo({
                  owner, repo,
                  state: 'open',
                  per_page: 100,
                  page
                });
                all.push(...data);
                if (data.length < 100) break;
                page++;
              }
              return all;
            }

            // Extract first URL from Upptime's body text
            function extractUrl(body) {
              if (!body) return null;
              // Prefer "(https://...)" pattern
              let m = body.match(/\((https?:\/\/[^)\s]+)\)/i);
              if (m && m[1]) return m[1];
              // Fallback to first http(s) URL
              m = body.match(/https?:\/\/[^\s)]+/i);
              return m ? m[0] : null;
            }

            // Simple timeout wrapper around fetch
            async function fetchWithTimeout(url, opts = {}, ms = 15000) {
              const ctrl = new AbortController();
              const t = setTimeout(() => ctrl.abort(), ms);
              try {
                return await fetch(url, { ...opts, signal: ctrl.signal });
              } finally {
                clearTimeout(t);
              }
            }

            // Determine if a status code is "up"
            function isUp(status) {
              return (status >= 200 && status < 400) || explicitOk.includes(status);
            }

            // Check URL with HEAD, then GET on 405/403/401 or HEAD not allowed
            async function checkUrlUp(url) {
              try {
                // Try HEAD without following redirects (many sites still respond 3xx)
                let res = await fetchWithTimeout(url, {
                  method: 'HEAD',
                  redirect: 'manual',
                  headers: { 'User-Agent': 'upptime-autoclose-bot' }
                }, 15000);

                // Some servers disallow HEAD or respond 403/401 to HEAD:
                if (res.status === 405 || res.status === 501 || res.status === 403 || res.status === 401) {
                  res = await fetchWithTimeout(url, {
                    method: 'GET',
                    redirect: 'follow',
                    headers: { 'User-Agent': 'upptime-autoclose-bot' }
                  }, 20000);
                }

                core.info(`Checked ${url} -> ${res.status}`);
                return isUp(res.status);
              } catch (e) {
                core.info(`Error checking ${url}: ${e.message}`);
                return false;
              }
            }

            const issues = await getOpenIssues();

            // Only consider Upptime incidents ("is down" in title)
            const incidents = issues.filter(i => /(^|\s)is down\b/i.test(i.title));

            core.info(`Found ${incidents.length} open incident issue(s).`);

            let closed = 0;
            for (const issue of incidents) {
              // Extract URL from the body
              const url = extractUrl(issue.body);
              if (!url) {
                core.info(`Issue #${issue.number} has no detectable URL; skipping`);
                continue;
              }

              // Check if the site is back up
              const up = await checkUrlUp(url);

              if (up) {
                await github.rest.issues.createComment({
                  owner, repo,
                  issue_number: issue.number,
                  body: `âœ… Auto-close bot: Site responded as **up**. Closing this incident.\n\nURL checked: ${url}`
                });

                await github.rest.issues.update({
                  owner, repo,
                  issue_number: issue.number,
                  state: 'closed',
                });

                core.info(`Closed #${issue.number} (${issue.title})`);
                closed++;
              } else {
                core.info(`Still down: #${issue.number} (${issue.title})`);
              }

              // small spacing to be polite to rate limits
              await new Promise(r => setTimeout(r, 400));
            }

            core.summary
              .addHeading('Auto-close summary')
              .addRaw(`Checked ${incidents.length} incident(s).`)
              .addRaw(`<br/>Closed ${closed} incident(s).`)
              .write();
